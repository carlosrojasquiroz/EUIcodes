function [g_a,g_c]=egm_i(p,m,B,g_a)
%---------------------------------------------------------------------------------------------------------------------------
%% Auxilary matrices of transition probabilities (for the next period)
%---------------------------------------------------------------------------------------------------------------------------
%   For low agg. + low idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
P_Ll=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
P_Ll(1,:,1,:)=m.P(1,1)*ones(p.naa,p.nKK);
P_Ll(2,:,1,:)=m.P(2,1)*ones(p.naa,p.nKK);
P_Ll(1,:,2,:)=m.P(3,1)*ones(p.naa,p.nKK);
P_Ll(2,:,2,:)=m.P(4,1)*ones(p.naa,p.nKK);
%---------------------------------------------------------------------------------------------------------------------------
%   For low agg. + high idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
P_Lh=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
P_Lh(1,:,1,:)=m.P(1,2)*ones(p.naa,p.nKK);
P_Lh(2,:,1,:)=m.P(2,2)*ones(p.naa,p.nKK);
P_Lh(1,:,2,:)=m.P(3,2)*ones(p.naa,p.nKK);
P_Lh(2,:,2,:)=m.P(4,2)*ones(p.naa,p.nKK);
%---------------------------------------------------------------------------------------------------------------------------
%   For high agg. + low idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
P_Hl=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
P_Hl(1,:,1,:)=m.P(1,3)*ones(p.naa,p.nKK);
P_Hl(2,:,1,:)=m.P(2,3)*ones(p.naa,p.nKK);
P_Hl(1,:,2,:)=m.P(3,3)*ones(p.naa,p.nKK);
P_Hl(2,:,2,:)=m.P(4,3)*ones(p.naa,p.nKK);
%---------------------------------------------------------------------------------------------------------------------------
%   For high agg. + high idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
P_Hh=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
P_Hh(1,:,1,:)=m.P(1,4)*ones(p.naa,p.nKK);
P_Hh(2,:,1,:)=m.P(2,4)*ones(p.naa,p.nKK);
P_Hh(1,:,2,:)=m.P(3,4)*ones(p.naa,p.nKK);
P_Hh(2,:,2,:)=m.P(4,4)*ones(p.naa,p.nKK);
%---------------------------------------------------------------------------------------------------------------------------
%% Auxilary matrices (for computing interest rate, wage and wealth)  
%---------------------------------------------------------------------------------------------------------------------------
% For assets
%---------------------------------------------------------------------------------------------------------------------------
a_aux=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
a_aux(1,:,1,:)=m.a_grid'*ones(1,p.nKK);
a_aux(2,:,1,:)=m.a_grid'*ones(1,p.nKK);
a_aux(1,:,2,:)=m.a_grid'*ones(1,p.nKK);
a_aux(2,:,2,:)=m.a_grid'*ones(1,p.nKK);
%---------------------------------------------------------------------------------------------------------------------------
% For the mean of capital distribution
%---------------------------------------------------------------------------------------------------------------------------
K_aux=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
K_aux(1,:,1,:)=ones(p.naa,1)*m.K_grid;
K_aux(2,:,1,:)=ones(p.naa,1)*m.K_grid;
K_aux(1,:,2,:)=ones(p.naa,1)*m.K_grid;
K_aux(2,:,2,:)=ones(p.naa,1)*m.K_grid;
%---------------------------------------------------------------------------------------------------------------------------
% For the aggregate shock (Z)
%---------------------------------------------------------------------------------------------------------------------------
Z_aux=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
Z_aux(:,:,1,:)=m.Z_grid(1)*ones(p.nzz,p.naa,p.nKK); 
Z_aux(:,:,2,:)=m.Z_grid(2)*ones(p.nzz,p.naa,p.nKK);
%---------------------------------------------------------------------------------------------------------------------------
% For the idiosyncratic shock (z)
%---------------------------------------------------------------------------------------------------------------------------
z_aux=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
z_aux(1,:,:,:)=m.z_grid(1)*ones(p.naa,p.nZZ,p.nKK); 
z_aux(2,:,:,:)=m.z_grid(2)*ones(p.naa,p.nZZ,p.nKK);
%--------------------------------------------------------------------------------------------------------------------------- 
%% A new mean of capital distribution (K'=g_K) for the given vector of the ALM 
%---------------------------------------------------------------------------------------------------------------------------
g_K=zeros(p.nzz,p.naa,p.nZZ,p.nKK); 
g_K(1,:,1,:)=exp(B(1)*ones(p.naa,p.nKK)+B(2)*log(reshape(K_aux(1,:,1,:),...
    p.naa,p.nKK)));
g_K(2,:,1,:)=exp(B(1)*ones(p.naa,p.nKK)+B(2)*log(reshape(K_aux(2,:,1,:),...
    p.naa,p.nKK)));
g_K(1,:,2,:)=exp(B(3)*ones(p.naa,p.nKK)+B(4)*log(reshape(K_aux(1,:,2,:),...
    p.naa,p.nKK)));
g_K(2,:,2,:)=exp(B(3)*ones(p.naa,p.nKK)+B(4)*log(reshape(K_aux(2,:,2,:),...
    p.naa,p.nKK)));
g_K=(g_K>=p.K_min).*(g_K<=p.K_max).*g_K+(g_K<p.K_min)*p.K_min+...
    (g_K>p.K_max)*p.K_max;
%---------------------------------------------------------------------------------------------------------------------------
%% Interest rate and wage given "a" and "K"
%---------------------------------------------------------------------------------------------------------------------------
% Current period
[rg_aux,w_aux]=prices(p,K_aux,m.L,Z_aux);
% Future period (conditional on state)
[rg_bad,w_bad]=prices(p,g_K,m.L,m.Z_grid(1));
[rg_good,w_good]=prices(p,g_K,m.L,m.Z_grid(2));
%---------------------------------------------------------------------------------------------------------------------------
%% Wealth
%---------------------------------------------------------------------------------------------------------------------------
wealth=(1+rg_aux).*a_aux+w_aux.*z_aux;
%---------------------------------------------------------------------------------------------------------------------------
%% Algorithm
%---------------------------------------------------------------------------------------------------------------------------
dif_k=1;
iter=0;
tic
while dif_k>p.tol
%---------------------------------------------------------------------------------------------------------------------------       
%   For a low agg. + low idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
    app_Ll=interpn(m.a_grid,m.K_grid,reshape(g_a(1,:,1,:),p.naa,p.nKK),g_a,g_K,...
        'spline'); 
    cp_Ll=w_bad.*m.z_grid(1)+(1+rg_bad).*g_a-app_Ll; 
    cp_Ll=(cp_Ll>0).*cp_Ll+(cp_Ll<=0)*0; 
    Ucp_Ll=cp_Ll.^(-p.sigma);
%---------------------------------------------------------------------------------------------------------------------------
%   For a low agg. + high idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
    app_Lh=interpn(m.a_grid,m.K_grid,reshape(g_a(2,:,1,:),p.naa,p.nKK),g_a,g_K,...
        'spline'); 
    cp_Lh=w_bad.*m.z_grid(2)+(1+rg_bad).*g_a-app_Lh; 
    cp_Lh=(cp_Lh>0).*cp_Lh+(cp_Lh<=0)*0; 
    Ucp_Lh=cp_Lh.^(-p.sigma);
%---------------------------------------------------------------------------------------------------------------------------
%   For a high agg. + low idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
    app_Hl=interpn(m.a_grid,m.K_grid,reshape(g_a(1,:,2,:),p.naa,p.nKK),g_a,g_K,...
       'spline'); 
    cp_Hl=w_good.*m.z_grid(1)+(1+rg_good).*g_a-app_Hl; 
    cp_Hl=(cp_Hl>0).*cp_Hl+(cp_Hl<=0)*0; 
    Ucp_Hl=cp_Hl.^(-p.sigma);
%---------------------------------------------------------------------------------------------------------------------------
%   For a high agg. + high idios. shocks
%---------------------------------------------------------------------------------------------------------------------------
    app_Hh=interpn(m.a_grid,m.K_grid,reshape(g_a(2,:,2,:),p.naa,p.nKK),g_a,g_K,...
        'spline'); 
    cp_Hh=w_good.*m.z_grid(2)+(1+rg_good).*g_a-app_Hh; 
    cp_Hh=(cp_Hh>0).*cp_Hh+(cp_Hh<=0)*0; 
    Ucp_Hh=cp_Hh.^(-p.sigma);
%---------------------------------------------------------------------------------------------------------------------------   
% Expectation term in the Euler equation
%---------------------------------------------------------------------------------------------------------------------------   
    EUcp=(Ucp_Ll.*(1+rg_bad)).*P_Ll+(Ucp_Lh.*(1+rg_bad)).*P_Lh+...
    (Ucp_Hl.*(1+rg_good)).*P_Hl+(Ucp_Hh.*(1+rg_good)).*P_Hh;
%---------------------------------------------------------------------------------------------------------------------------   
% Consumption policy
%---------------------------------------------------------------------------------------------------------------------------      
   g_c_new=(p.beta*EUcp).^(-1/p.sigma); 
%---------------------------------------------------------------------------------------------------------------------------   
% Individual assets policy
%---------------------------------------------------------------------------------------------------------------------------                        
   g_a_new=wealth-g_c_new; 
   g_a_new=(g_a_new>=p.a_min).*(g_a_new<=p.a_max).*g_a_new+(g_a_new<p.a_min).*p.a_min+...
       (g_a_new>p.a_max).*p.a_max; 
   dif_k=max(max(max(max(abs(g_a_new-g_a)))));    
   g_a=p.update_a.*g_a_new+(1-p.update_a).*g_a;
%---------------------------------------------------------------------------------------------------------------------------   
% Information about the algorithm
%---------------------------------------------------------------------------------------------------------------------------    
   iter=iter+1;
   if p.disp1==1
       disp(['Iteration number ',num2str(iter)]);  
       disp(['Tolerance criterion ',num2str(dif_k)]);
   end
end
endtime=toc;
if p.disp1==1
    disp(['Time to execute the algorithm ',num2str(endtime)]);  
end
g_c=wealth-g_a;
%---------------------------------------------------------------------------------------------------------------------------